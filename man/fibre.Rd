% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fibre-fit.R, R/fibre.R
\name{fibre}
\alias{fibre}
\alias{fibre.default}
\alias{fibre.data.frame}
\alias{fibre.matrix}
\alias{fibre.formula}
\alias{fibre.recipe}
\title{Fit a \code{fibre}}
\usage{
fibre(
  formula = ~1,
  data = NULL,
  family = "gaussian",
  rate_comb = NULL,
  fit = TRUE,
  obs_error = "est",
  verbose = TRUE,
  inla_verbose = FALSE,
  threads = 1,
  inla_threads = NULL,
  ...
)

fibre.default(x, ...)

fibre.data.frame(x, y, ...)

fibre.matrix(x, y, ...)

fibre.formula(formula, data, ...)

fibre.recipe(x, data, ...)

fibre(
  formula = ~1,
  data = NULL,
  family = "gaussian",
  rate_comb = NULL,
  fit = TRUE,
  obs_error = "est",
  verbose = TRUE,
  inla_verbose = FALSE,
  threads = 1,
  inla_threads = NULL,
  ...
)
}
\arguments{
\item{formula}{formula specifying the response (LHS) and set of predictors (RHS) for the
phylogenetic model. The default \code{ ~ 1} is special shorthand specifying a model of
a response with only a phylogenetic model (e.g. no covariates), in which case, the \code{data}
argument must contain a vector or column matrix/data.frame with the response variable(s)
(e.g. species traits).}

\item{data}{A matrix or data.frame (or vector) containing the variables referred to in
\code{formula} argument.}

\item{family}{Family for the distribution of tip errors. Default is "gaussian", but can be any
supported by \code{inla}. See \code{names(inla.models()$likelihood)} for a list of possibilities
and use \code{\link[INLA]{inla.doc}} for details of all available families. Note that for
most families besides \code{"gaussian"}, the 'trait' who's evolution is being modeled will
be a 'latent' trait representing the 'mean' parameter of the error distribution and it will be
linked to the data through a standard transformation. As an example, a \code{"binomial"} model
with binary response will have a latent gaussian trait that represents the probability of the tip
traits being a one as opposed to a zero and will be transformed using a logit function (by default)
to keep the probability between 0 and 1.}

\item{verbose}{Whether to print information about the progress of \code{fiber}}

\item{inla_verbose}{Whether \code{\link[INLA:inla]{INLA::inla()}} should be run in verbose mode.}

\item{threads}{Number of threads to use to parallelize computation of the root to
matrix (default: 1). This can speed things up quite a bit for large trees, but
also tends to use a lot of memory, because the entire tree must be copied to
each thread.}

\item{inla_threads}{How many threads should the inla fitting process use?
Default is \code{INLA::inla.getOption("num.threads")}. See \code{\link[INLA:inla]{INLA::inla()}} for how to set this correctly.}

\item{...}{Additional arguments to be passed to \code{\link[INLA:inla]{INLA::inla()}}}

\item{x}{Depending on the context:
\itemize{
\item A \strong{data frame} of predictors.
\item A \strong{matrix} of predictors.
\item A \strong{recipe} specifying a set of preprocessing steps
created from \code{\link[recipes:recipe]{recipes::recipe()}}.
}}

\item{y}{When \code{x} is a \strong{data frame} or \strong{matrix}, \code{y} is the outcome
specified as:
\itemize{
\item A \strong{data frame} with 1 numeric column.
\item A \strong{matrix} with 1 numeric column.
\item A numeric \strong{vector}.
}}

\item{phy_match}{This argument specifies how the data should be matched to the phylogeny. The
default \code{"auto"}, will match by names or rownames if they exist in \code{data}, or match
by order if no names are present. You can also explicitly specify how to match (recommended).
Option include "names", to match by names (throwing an error if they aren't present), "order", to
match by ordering (element or rows in \code{data} are in the same order as \code{phy$tip.label}),
or any length 1 character vector that refers to a column name in \code{data}, containing a character
vector. In this case, this character vector will be used to match the data to the tip labels in
\code{phy}. This is the recommended best way, as it is the most compatible with "tidy" principles,
making sure species names are treated as data and stay associated with related data.}

\item{rate_model}{The model to use for the evolutionary rate variation along the phylogeny
(in other words, the choice of prior for rates). Current choices are:
\itemize{
\item{\code{"iid"}}{Rates are completely independent along all branches but are shrunk
towards zero by an independent Normal prior. This is classic Bayesian Ridge Regression and has
a single hyperparameter whose prior determines the degree of shrinkage.}
\item{\code{"phylogenetic"}}{Rates are modeled using a covariance structure derived from the phylogeny.
Therefore, rates can be thought of as evolving on the phylogeny according to a Brownian motion
model. This limits the degree to which rates can differ from the rates on their parent branch.
This model can be helpful when trying to predict missing values at tree tips because it provides
more information on how to draw rate values for terminal branches. However, it may limit
the ability to detect rare rate shifts. In this case, one could consider a combination
of both \code{"phylogenetic"} and \code{"iid"} models.}
}
More rate models will be implemented in the future. Note that rate models can be combined
by passing a character vector of length greater than one to this argument (e.g.
c("iid", "phylogenetic")) will include both rate models as additive factors in the model.}

\item{rate_order}{Can be either \code{"first_order"} or \code{"second_order"}. If \code{"first_order"} rates
are the signed rate of evolution along each branch. If \code{"second_order"} rates are actually
the rate of rate change, that is we model rates of evolution along a branch as the rate
of the parent branch plus some deviation from this rate: the parameters of the model are these
rate deviations instead of the rates themselves.}
}
\value{
A \code{fibre} object.
}
\description{
\code{fibre()} fits a model.
}
\examples{
predictors <- mtcars[, -1]
outcome <- mtcars[, 1]

# XY interface
mod <- fibre(predictors, outcome)

# Formula interface
mod2 <- fibre(mpg ~ ., mtcars)

# Recipes interface
library(recipes)
rec <- recipe(mpg ~ ., mtcars)
rec <- step_log(rec, disp)
mod3 <- fibre(rec, mtcars)

}
