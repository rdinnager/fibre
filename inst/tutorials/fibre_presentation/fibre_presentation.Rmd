---
title: "Introducing {fibre} for Fast and Flexible Phylogenetic Modelling in R"
output: 
  ioslides_presentation:
    widescreen: true
runtime: shiny_prerendered
---

```{css echo=FALSE}
@media print {
  .topicsContainer,
  .topicActions,
  .exerciseActions .skip {
    display: none;
  }
  .topics .tutorialTitle,
  .topics .section.level2,
  .topics .section.level3:not(.hide) {
    display: block;
  }
  .topics {
    width: 100%;
  }
  .tutorial-exercise, .tutorial-question {
    page-break-inside: avoid;
  }
  .section.level3.done h3 {
    padding-left: 0;
    background-image: none;
  }
  .topics .showSkip .exerciseActions::before {
    content: "Topic not yet completed...";
    font-style: italic;
  }
}
```

```{r setup, include=FALSE}
library(learnr)
library(fibre)

custom_checker <- function(label, user_code, check_code, envir_result, evaluate_result, envir_prep, last_value, stage, ...) {
  # this is a code check
  if(stage == "check") {
    
    rstudioapi::sendToConsole(user_code, focus = TRUE)
    
    fofpack::set_env(envir_result)

    list(message = "Code Run!", correct = TRUE, type = "success", location = "append")
    
  }

}

knitr::opts_chunk$set(echo = FALSE)

```

## Introducing `{fibre}`

- `{fibre}` is a phonetic respelling of the acronym PhyBR: *Phy*logenetic *B*ranch *R*egression
- `{fibre}` implements fast and flexible evolutionary models of traits on phylogenies
- Both for inference of rates of evolution of traits and for phylogenetic comparative methods

## The Basis of Phylogenetic Branch Regression

- Phylogenetic flows
  - An information flow through a tree-structured graph from a root node to a set of terminal nodes.
- Characterized by a (sparse) matrix: The root to node matrix
- Each row represents a flow from the root to a terminal node (usually tips, but not necessarily)
- Each column represents a branch of the phylogeny which each flow either flows through or doesn't (in which case it is zero)
- The structure of the phylogenetic tree is completely determined by the sparsity structure of the matrix
- The values of the non-zero elements can be branch lengths or any data associated with the phylogeny's edges

## Phylogenetic Flows as a Data Structure

- The package `{phyf}` handles phylogenetic flows as a type of `data.frame` or `tibble`
- Makes it easy to combine a phylogeny with data

## A simple example

```{r phyf_intro, exercise=TRUE}
set.seed(4534)
library(fibre)
library(phyf)
library(ape)
library(tidyverse)
library(ggtree)
library(patchwork)
library(latex2exp)
tree <- rcoal(4)
plot(tree, show.node.label = TRUE)
```

```{r phyf_intro-check}
ls()
```

## As a `pfc` object

- A `pfc` is a phylogenetic flow object
- Note that the root node is not contained in a `pfc` because it has no edge leading to it
- The notion of a root edge makes little sense in the context of phylogenetic flows

```{r phyf_intro2, exercise=TRUE}
tree_pfc <- pf_as_pfc(tree)
tree_pfc
```

```{r phyf_intro2-check}
ls()
```

## Tips vs. Nodes

- By default new `pfc` objects always have tips and internal nodes
- In practice, only the tip elements are useful for fitting models
- Internal node elements are useful for predicting ancestral states once a model is fit
- The entire tree structure is represented in the tip elements of the phylogenetic flow because in the set of flows from the root to all of the tips, all internal nodes must have been flowed through at least once

---

## Tips vs. Nodes

```{r phyf_intro3, exercise=TRUE}
tree_tips <- pf_tips(tree_pfc)
tree_tips

plot(pf_as_phylo(tree_pfc))
plot(pf_as_phylo(tree_tips))
```

```{r phyf_intro3-check}
ls()
```

## A Phylogenetic Flow object can be represented as sparse matrix

```{r phyf_intro4, exercise=TRUE}
pf_as_sparse(tree_pfc)
```

```{r phyf_intro4-check}
ls()
```

## Visualise sparse matrix

## Why does this matter?
### A Model of trait Evolution

- Evolution of a trait can be expressed simply in terms of phylogenetic flow.
- A trait at the tip of the tree is equal to the value of the trait at the root plus the sum of the evolutionary changes along each branch between that tip and the root, that is, along the phylogenetic flow for that tip.
- Generally we want to put this in terms of the rates of evolution, such that the change in the trait along each branch is the rate times the branch length.

$$\text{trait}_i = \text{trait}_0 + \sum_{e \subset \text{flow}_i} l_e r_e$$
Where $\text{trait}_0$ is the trait value at the root node.

## With `{phyf}` we can do tree 'arithmetic'

```{r tree_arith, exercise=TRUE}
rates <- matrix(rnorm(6), nrow = 1)
rates

tree_pfc
tree_pfc * rates
```

```{r tree_arith-check}
ls()
```

## With `{phyf}` we can do tree 'arithmetic'

```{r tree_arith2, exercise=TRUE}
root <- 2
root + pf_flow_sum(tree_pfc * rates)
```

```{r tree_arith2-check}
ls()
```

## But that whole procedure can be done with one matrix multiplication

```{r tree_arith3, exercise=TRUE}
root + pf_as_sparse(tree_pfc) %*% t(rates)
```

```{r tree_arith3-check}
ls()
```

## This is very efficient

- simulate trait evolution on large tree

```{r sim_vert, exercise=TRUE}
vert_bmr
sum(vert_bmr$is_tip)
system.time(
  traits <- root + pf_as_sparse(vert_bmr) %*% matrix(rnorm(pf_nedges(vert_bmr$phlo)))
)
autoplot(vert_bmr %>% mutate(sim_trait = traits[ , 1]), sim_trait)
```

```{r sim_vert-check}
ls()
```

## But how to we estimate the parameters?

- One parameter per edge (the rates): $n_{edge} = n_{tips} + (n_{tips} - 1)$ for bifurcating tree
- $n_{edge} > n_{tips}$: the number of parameters exceeds the number of data points 
- Generally, this problem is solved by adding additional constraints on the model so that parameters are not completely 'free'
- In a Bayesian framework, this is achieved with prior distributions

## Let's put a simple Gaussian prior on our rates

$$\text{trait}_i = \text{trait}_0 + \sum_{e \subset \text{flow}_i} l_e r_e + \text{error}_i$$
$$\text{error}_i \sim \text{Normal}\left(0, \sigma^2\right)$$
$$r_e \sim \text{Normal}\left(0, \tau^2\right)$$
## What is this model?

- I call it Phylogenetic Branch Regression (PhyBR, or fibre, phonetically)
- This model is trivial to fit in a number of Bayesian modelling frameworks, including INLA (which uses an Integrated Nested Laplace Approximation for very fast inference)
- Given the simplicity of this model, has anyone done it before?
- Sort of: It is possible to show that the maximum a posterior (MAP) estimate of this model is equivalent to the maximum likelihood solution of phylogenetic ridge regression with penalty factor $\lambda = \frac{\sigma^2}{\tau^2}$

## A relationship with Brownian motion

- Phylogenetic trait models based on Brownian motion are classic models (and often unfairly criticized, more on that later).
- Brownian motion is based on a stochastic process know as the Wiener process. 
- They should be called phylogenetic Wiener models, because the historical connection with the physical process of Brownian motion has not aided our interpretations of this model in my opinion.
- The Wiener process is characterized by four properties:

## In a phylogenetic context, this all adds up to...

- The change in a trait along the edges of a phylogeny are distributed according to

$$\Delta\text{trait}_e \sim \text{Normal}\left(0, \phi^2 l_e\right)$$
where $\phi^2$ is the evolutionary 'rate' parameter (more often referred to as $\sigma^2$, but I reserve that for the observation-level error distribution). But:
$$\Delta\text{trait}_e = l_e r_e$$
----

So we have:

$$l_e r_e \sim \text{Normal}\left(0, \phi^2 l_e\right)$$
and therefore:

$$\frac{l_e r_e}{l_e} \sim \text{Normal}\left(0, \frac{\phi^2 l_e}{l_e^2}\right)$$
$$r_e \sim \text{Normal}\left(0, \phi^2 \sqrt l_e\right)$$

## A Phylogenetic Wiener Process Model

- So this (highly efficient) model is equivalent to a Wiener Process when using square root transformed edge lengths!
- This also implies that the plain fibre model is equivalent to phylogenetic Brownian motion with squared branch-lengths (which also happens to be equivalent to a Pagel's Kappa model with $\kappa = 2$) 

## A simple Brownian motion model

```{r model_brownian, exercise=TRUE}
mod <- fibre(scale(log(Mass + 1)) ~ bre_brownian(phlo),
             data = avonet,
             engine_options = list(verbose = TRUE))
```

```{r model_brownian-check}
ls()
```

## Using a 'Second-Order' model

```{r model_second_order, exercise=TRUE}
mod2 <- fibre(scale(log(Mass + 1)) ~ bre_second_order(phlo),
              data = avonet)
```

```{r model_second_order-check}
ls()
```

## Predictions

```{r preds1, exercise=TRUE}
preds <- predict(mod, avonet)
preds
```

```{r preds1-check}
ls()
```

## Predictions

```{r preds2, exercise=TRUE}
avonet_w_preds <- avonet %>% bind_cols(preds)

water_bird_preds <- avonet_w_preds %>%
  filter(pf_is_desc(phlo, pf_mrca(phlo[c("Platalea_minor", "Pelecanus_occidentalis")])))
p <- autoplot(water_bird_preds, 
              .pred_mean,
              layout = "rectangular") + xlim(0, 100)
p
```

```{r preds2-check}
ls()
```


## Uncertainty

```{r preds3, exercise=TRUE}
p2 <- autoplot(water_bird_preds, 
              .pred_sd,
              layout = "rectangular") + xlim(0, 100)
p2
```

```{r preds3-check}
ls()
```

## Get an Order subtree

```{r preds4, exercise=TRUE}
Galliformes_preds <- avonet_w_preds %>%
  filter(pf_is_desc(phlo, pf_mrca(phlo[which(Order3 == "Galliformes")])))
p3 <- autoplot(Galliformes_preds, 
              .pred_mean,
              layout = "circular") + xlim(0, 100) 
p3
```

```{r preds4-check}
ls()
```

## Uncertainty

```{r preds5, exercise=TRUE}
p4 <- autoplot(Galliformes_preds, 
               .pred_mean,
               layout = "circular",
               suppress_tiplabels = TRUE) + 
  autoplot(Galliformes_preds, 
           .pred_sd,
           layout = "circular",
           suppress_tiplabels = TRUE) 
p4
```

```{r preds5-check}
ls()
```
